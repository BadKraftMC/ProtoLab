using System.Text.Json;

using ProtoLab.OpenTest.Runtime;
using ProtoLab.OpenTest.Serialization;

// See https://aka.ms/new-console-template for more information
Console.WriteLine("Initializing ProtoLab OpenTest");

const string SOURCE = "-s";
/* **
    Not used - removed to reconsider what the AgentLogger will do and what the benefit will be
** */
// const string OUTPUT = "-l";

AgentState agentState = AgentState.Initialize;
RunStatus status = RunStatus.Okay;
Dictionary<int, string> ERROR_DESCRIPTIONS = new()
{
    { 1001, "Directory Not Found"},
    { 1002, "Not Implemented" },
    { 1003, "No Test Cases discovered" }
};
Assembly assembly = null;

while (agentState != AgentState.Exit)
{
    switch (agentState)
    {
        case AgentState.Initialize:
            status = Initialize(ref agentState, args);

            break;
        case AgentState.Begin:
            status = Begin(ref agentState, args, out assembly);

            break;
        case AgentState.Configure:
            status = Configure(ref agentState, assembly);

            break;
        case AgentState.Execute:
            status = Run(ref agentState);

            break;
        case AgentState.CleanUp:
            status = CleanUp(ref agentState);

            break;
        case AgentState.End:
        default:
            status = End(ref agentState);

            //LogStream.Close();
            Console.SetOut(Output);
            break;
    }

    if (status == RunStatus.Error && agentState != AgentState.Exit)
    {
        string description = string.Empty;
        switch (ErrCode)
        {
            case 1001:
                description = $"could not find '{Parameters[Args.Source]}' in {Directory.GetCurrentDirectory()}";

                break;
            case 1002:

                break;
            case 1003:
                description = $"Assembly '{assembly?.GetName().Name}' has no discoverable test cases";

                break;
        }

        Console.WriteLine($"[{ErrCode}] {ERROR_DESCRIPTIONS[ErrCode]}: \n{' ',15}{description}");

        agentState = AgentState.End;
    }
}

Console.WriteLine($"OpenTest TestAgent has exited with code {(int)status} [{status}:{ErrCode}].");

#region execution states
static RunStatus Initialize(ref AgentState agentState, string[] args)
{
    RunStatus status = RunStatus.Okay;

    //  args input length just need not be zero
    if (args.Length > 0)
    {
        var iterator = args.AsReadOnly()
                           .GetEnumerator();
        while (iterator.MoveNext())
        {
            string[] param = iterator.Current.Split(' ', StringSplitOptions.TrimEntries);

            switch (param[0])
            {
                case SOURCE:
                    //  we are going to just try and add - 2nd -s will not override previous values
                    Parameters.TryAdd(Args.Source, param[1]);

                    break;
                // case OUTPUT:
                //     //  same; do not overwrite a previous value -- parameter log file is not currently used
                //     Parameters.TryAdd(Args.Output, string.Empty);

                //     break;
                default:
                    break;
            }
        }

        /* ** removed AgentLogger configuration for reconsideration and redesign
        //  configuring stream first should give us output to log file right away
        Stream stream;
        //  checks to ensure we configure a console output stream (TextWriter)
        if (TrySetParameter(Args.Output, "Default"))
        {
            stream = Console.OpenStandardOutput();
        }
        else
        {
            //  now that we have a validated source, we can get the working 
            //      directory and append the correct test case log directory
            stream = InitDefaultLogging();
        }

        ConfigureLogger(stream);
        ** */

        //  if we don't have Args.Source then we need to stop
        if (!ValidateSource())
        {
            agentState = AgentState.End;
            return RunStatus.Error;
        }

        agentState = AgentState.Begin;
    }

    return status;
}

static RunStatus Begin(ref AgentState agentState, string[] args, out Assembly assembly)
{
    RunStatus status = RunStatus.Okay; ;

    // Logger.WriteLine("Begin TestCase Discovery ...");

    if (!TryLoadAssembly(out assembly))
    {
        ErrCode = 1003;
        status = RunStatus.Error;
    }
    else
    { /* Logger.WriteLine($"Assembly Loaded: {assembly.GetName().Name}"); */ }

    agentState = AgentState.Configure;

    return status;
}

static RunStatus Configure(ref AgentState agentState, Assembly assembly)
{
    Agent = TestContext.Current.CreateAgent(assembly, TestSets);

    agentState = AgentState.Execute;

    return RunStatus.Okay;
}

static RunStatus Run(ref AgentState agentState)
{
    // Logger.WriteLine("Execute Agent Test Runner ...");

    Agent.Start();

    agentState = AgentState.CleanUp;

    return RunStatus.Okay;
}

static RunStatus CleanUp(ref AgentState agentState)
{
    // Logger.WriteLine("Clean Up Test Agent ...");
    agentState = AgentState.End;

    return RunStatus.Okay;
}

static RunStatus End(ref AgentState agentState)
{
    RunStatus runStatus = RunStatus.Okay;

    if (ErrCode == 0)
    {
        //  everything proceded as it should
        // Logger.WriteLine("End OpenTest TestCases");
    }
    else
    {
        runStatus = RunStatus.Error;
    }

    agentState = AgentState.Exit;
    OutputTestRunResults();

    return runStatus;
}
#endregion

public static partial class Program
{
    private const string TESTLOGDIR = "TestCaseLogs";

    private static JsonSerializerOptions JsonOptions { get; } = new()
    {
        WriteIndented = true
    };

    static Dictionary<Args, string> Parameters { get; } = new();
    static TextWriter Output { get; set; } = Console.Out;
    // static AgentLogger Logger { get; set; }
    static DirectoryInfo Working { get; set; } = new("null");
    static DirectoryInfo TestLogs { get; set; } = new("null");
    static FileInfo Target { get; set; } = new("null");
    static Dictionary<Type, List<MethodInfo>> TestSets { get; } = new();
    static int ErrCode { get; set; } = 0;
    static Agent Agent { get; set; } = null;
    /// <summary>
    /// Valide target directory contains the expected .dll
    /// </summary>
    static bool ValidateSource(string target)
    {
        // target = $@".\{target}";
        // var current = Directory.GetCurrentDirectory();

        if (!Directory.Exists(target))
        {
            ErrCode = 1001;

            return false;
        }

        //  make sure we have an assembly in the directory - 
        //      we're going to assume (for now) that the directory name is the name of the .dll to test
        Working = new(target);
        string assemblyFile = $"{Working.Name}.dll";

        if (!TryFindFile(Working, assemblyFile, out FileInfo targetFile))
        {
            ErrCode = 1002;

            // return false;
        }

        //  if target file is null, we did not find the file
        return (Target = targetFile) != null;
    }
    static bool ValidateSource()
    {
        if (!Parameters.TryGetValue(Args.Source, out string target))
        {
            //  LOGGER stream is not configured -- nothing will be output yet
            // Logger.WriteLine("Invalid Target Parameter");

            return false;
        }

        return ValidateSource(target);
    }
    /// <summary>
    /// Initializes the test case logging consumer
    /// </summary>
    static Stream InitDefaultLogging()
    {
        // //  assumption: Working directory has been initized if necessary
        // if(TestLogs.Name == "null") {
        //     //  nothing to change, should be default console text writer
        //     return;
        // }

        //  construct test case logging directory - default to Parent directory to resolve null working directory bug
        string testLogDir = Path.Combine(Working.Parent.FullName, TESTLOGDIR);
        if (!Directory.Exists(testLogDir))
        {
            Directory.CreateDirectory(testLogDir);
        }

        TestLogs = new(testLogDir);
        //  construct file path
        string testLogFile = Path.Combine(TestLogs.FullName, $"{DateTime.Now:MMddyyyyHHmm}.log");

        return new FileStream($"{testLogFile}", FileMode.Create);
    }
    /// <summary>
    /// Tries to find a file with standardized search method
    /// </summary>
    static bool TryFindFile(DirectoryInfo working, string assemblyFile, out FileInfo fileInfo)
    {
        return (fileInfo = new FileInfo(FindFile(Working, assemblyFile) ?? string.Empty)).Exists;
    }
    /// <summary>
    /// Recursive method to locate file including search through subdirectories
    /// </summary>
    static string FindFile(DirectoryInfo directory, string assemblyFile)
    {
        FileInfo file = null;

        //  1. check if assembly file exists in this directory
        if (directory.GetFiles().Where(f =>
        {
            if (f.Name.Equals(assemblyFile))
            {
                file = f;
            }

            return file != null;
        }).Any())
        {
            return file?.FullName;
        }

        //  2. check for directories
        IEnumerator<DirectoryInfo> subDirectories = directory.GetDirectories()
            .AsEnumerable()
            .GetEnumerator();
        while (subDirectories.MoveNext() && file == null)
        {
            string filePath = FindFile(new(subDirectories.Current.FullName), assemblyFile);

            file = filePath != null ? new(filePath) : file;
        }

        return file?.FullName;
    }
    /// <summary>
    /// Attempts to load an assembly
    /// </summary>
    static bool TryLoadAssembly(out Assembly assembly)
    {
        // Logger.WriteLine("Loading Assembly ...");

        return HasTestCases(assembly = Assembly.LoadFrom(Target.FullName));
    }
    /// <summary>
    /// Attempts to set an initialization parameter
    /// </summary>
    static bool TrySetParameter(Args argType, string parameter)
    {
        return Parameters.TryAdd(argType, parameter);
    }
    /// <summary>
    /// Determines if the test set container has methods (Test Cases)
    /// </summary>
    static bool HasTestCases(Assembly assembly)
    {
        //  look for test cases - methods decorated with [TestCase]
        var types = assembly.GetTypes();
        List<MethodInfo> methods;
        List<string> ignored = new();

        foreach (var t in types)
        {
            methods = new();

            foreach (var m in t.GetMethods().Where(y => y.GetCustomAttributes().OfType<TestCaseAttribute>().Any()))
            {
                var tc = m.GetCustomAttribute<TestCaseAttribute>();
                if (tc.Ignore)
                {
                    ignored.Add(m.Name);

                    continue;
                }

                methods.Add(m);
            }

            if (methods.Count > 0)
            {
                TestSets.Add(t, methods.ToList());
            }
        }

        return TestSets
            .Where(kv => types.Any(t => t.Equals(kv.Key)))
            .Any();
    }
    static void OutputTestRunResults()
    {
        JsonOptions.Converters.Add(new ResultOutputConverter());

        var resultSet = Agent.GetResultLogs();
        var resultsDir = Path.Combine(Working.Name, $"{resultSet.Assembly} Test Results");

        if (!Directory.Exists(resultsDir))
        {
            Directory.CreateDirectory(resultsDir);
        }

        var resultsFile = Path.Combine(resultsDir, $"{resultSet.Assembly}_results.json");
        using (var stream = File.Create(resultsFile))
        {
            var json = JsonSerializer.Serialize(resultSet, JsonOptions);
            stream.Write(Encoding.UTF8.GetBytes(json));
        }
    }
    /// <summary>
    /// Configure Logging In/Out channels
    /// </summary>
    static void ConfigureLogger(Stream outputLogStream)
    {
        //  save the standard output.
        Output = Console.Out;
        // Logger = AgentLogger.Configure(outputLogStream);
    }
}